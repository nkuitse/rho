#!/usr/bin/perl

use strict;
use warnings;

use DBI;
use Time::HiRes qw(sleep time);
use POSIX qw(strftime);
use Cwd qw(getcwd);
use File::Basename qw(dirname basename);
use Getopt::Long
    qw(:config posix_default gnu_compat require_order bundling no_ignore_case);

sub usage;
sub fatal;

my $root = $ENV{'RHO_ROOT'} || getcwd;
my %database;
my %trx;

usage if !@ARGV;
run();

# --- Functions

sub run {
    usage if @ARGV < 1;
    my $repfile = shift @ARGV;
    my %arg = args(@ARGV);
    my $t0 = time;
    xchdir(dirname($repfile));
    my $report = read_report(basename($repfile));
    %database = ( %database, %{ $report->{'databases'} || {} } );
    check_args($report, \%arg);
    my $init = $report->{'initializers'};
    foreach my $q (ref($init) ? @$init: ($init)) {
        my $db = $q->{'target'};
        my $dbh = begin(dbh($db));
        my ($sth, @params) = prepare_sql($dbh, $q->{'body'}, \%arg);
        $sth->execute(@params);
    }
    my $iosteps = $report->{'iosteps'};
    foreach my $q (ref($iosteps) ? @$iosteps : ($iosteps)) {
        my ($r, $w) = @$q{qw(read write)};
        die "attempt to write to a read-only database $r->{'id'}"
            if $w->{'read_only'};
        my $reader = $database{$r->{'id'}} or die;
        my $writer = $database{$w->{'id'}} or die;
        my $wdbh = begin(dbh($writer));
        my ($rsth, @rparams) = prepare_sql(dbh($reader), $r->{'body'}, \%arg);
        my ($wsth, @wparams) = prepare_sql($wdbh, $w->{'body'}, \%arg);
        fatal "writer has external params" if @wparams;
        $rsth->execute(@rparams);
        while (my @row = $rsth->fetchrow_array) {
            $wsth->execute(@row);
        }
    }
    my $script = $report->{'script'};
    if (defined $script) {
        die 'not yet implemented';
    }
    my $finish = $report->{'finishers'};
    foreach my $q (ref($finish) ? @$finish : ($finish)) {
        my $db = $q->{'target'};
        my $dbh = begin(dbh($db));
        my ($sth, @params) = prepare_sql($dbh, $q->{'body'}, \%arg);
        $sth->execute(@params);
    }
    end();
}

sub begin {
    my ($dbh) = @_;
    my $trx = $trx{$dbh} ||= [ 0, $dbh ];
    if (++$trx->[0] == 1) {
        $dbh->begin_work;
    }
    return $dbh;
}

sub end {
    foreach my $trx (values %trx) {
        $trx->[1]->commit;
    }
    %trx = ();
}

sub prepare_sql {
    my ($dbh, $sql, $args) = @_;
    my @bind;
    $sql =~ s{
        < ([\$\@]) (\w+) >
    }{
        placeholder($1, $2, $args->{$2}, \@bind)
    }exg;
    my $sth = $dbh->prepare($sql);
    return ($sth, @bind);
}

sub placeholder {
    my ($sigil, $key, $val, $bind) = @_;
    if ($sigil eq '$') {
        if (ref($val)) {
            die if @$val > 1;
            ($val) = @$val;
        }
        push @$bind, $val;
        return '?';
    }
    elsif ($sigil eq '@') {
        die if !$val;
        $val = [$val] if !ref $val;
        my @val = @$val;
        push @$bind, @val;
        return join(', ', '?' x scalar(@val));
    }
    else {
        die "wtf?";
    }
}

sub prepare_sql_file {
    my ($dbh, $f, $params) = @_;
    open my $fh, '<', $f or fatal "open $f: $!";
    local $/;
    my $sql = <$fh>;
    my @params;
    if ($sql =~ s{\A/\*\s*PARAMS\s*\*/\n}{}) {
        while ($sql =~ s{\A/\*\s*([1-9][0-9]*)\s+(\S+)\s*\*/\n}{}) {
            my ($i, $k) = ($1, $2);
            $params[$i-1] = $params->{$k};
        }
    }
    my $sth = $dbh->prepare($sql);
    return ($sth, @params);
}

# --- Other functions

sub orient {
    my @databases;
    GetOptions(
        'r|root=s' => \$root,
        's|database=s' => \@databases,
        @_,
    ) or usage;
    xchdir($root);
    %database = read_databases(@databases);
}

sub dbh {
    my ($db) = @_;
    my $database = ref($db) ? $db : $database{$db} // fatal "no such database: $db";
    return $database->{'dbh'} ||= DBI->connect(@$database{qw(dsn user password)}, { 'RaiseError' => 1, 'AutoCommit' => 1 });
}

sub run_script {
    my ($fscr, $o, $param) = @_;
    my @params = map { $_ . '=' . $param->{$_} } keys %$param;
    system($fscr, $o, @params) == 0 or fatal "script failed";
}

sub xchdir {
    foreach my $dir (@_) {
        chdir $dir or fatal "chdir $dir: $!";
    }
}

sub xmkdir {
    foreach my $dir (@_) {
        -d $dir or mkdir $dir or fatal "mkdir $dir: $!";
    }
}

sub args {
    my %param;
    foreach (@_) {
        my ($k, $v) = split /=/, $_, 2;
        if (exists $param{$k}) {
            $param{$k} = [ $param{$k} ] if !ref $param{$k};
            push @{ $param{$k} }, $v;
        }
        else {
            $param{$k} = $v;
        }
    }
    return %param;
}

sub check_args {
    my ($report, $args) = @_;
    my $params = $report->{'parameters'};
    # For example:
    #   $params = {
    #     'msg' => {
    #       key => 'msg',
    #       qualifiers => {
    #         default => 'Hello world',
    #       },
    #       title => 'Message',
    #     },
    #   };
    foreach my $param (values %$params) {
        my $key = $param->{'key'};
        my $qual = $param->{'qualifiers'} || {};
        my $title = $param->{'title'};
        if (!exists $args->{$key}) {
            if (exists $qual->{'default'}) {
                $args->{$key} = $qual->{'default'};
            }
            elsif ($qual->{'required'}) {
                fatal "required parameter not specified: $key $title";
            }
        }
    }
}

sub read_report {
    my ($f) = @_;
    my %report = (
        'metadata' => {},
        'parameters' => {},
        'databases' => {},
        'initializers' => [],
        'iosteps' => [],
        'finishers' => [],
    );
    _read_file($f, \%report);
}

sub _read_file {
    my ($f, $report, %limits) = @_;
    open my $fh, '<', $f or die;
    local $_;
    {
        local $/;
        $_ = <$fh>;
    }
    my ($meta, $param, $database, $inits, $iosteps, $finishers)
        = @$report{qw(metadata parameters databases initializers iosteps finishers)};
    while (s/\A\s*(?=\S)//) {
        _strip_comments();
        my ($block, $type, $include);
        if ($block = _metadata()) {
            $type = 'metadata';
            %$meta = ( %$meta, %{ $block->{'body'} } );
        }
        elsif ($block = _parameters()) {
            $type = 'parameters';
            %$param = ( %$param, %{ $block->{'body'} } );
        }
        elsif ($block = _database()) {
            $type = 'databases';
            my $id = $block->{'body'}{'id'} = delete $block->{'id'};
            $block->{'body'}{'title'} = delete $block->{'title'};
            $database->{$id} = $block->{'body'};
            ### my $hash = delete $block->{'body'};
            ### %$hash = ( %$block, %$hash );
        }
        elsif ($block = _init()) {
            $type = 'initializers';
            push @$inits, $block;
        }
        elsif ($block = _iostep()) {
            $type = 'iosteps';
            push @$iosteps, $block;
        }
        elsif ($block = _finish()) {
            $type = 'finishers';
            push @$finishers, $block;
        }
        elsif ($include = _include()) {
            $type = 'include';
        }
        else {
            my ($line) = split /\n/;
            fatal "unparseable: line in file $f: $line";
        }
        if (defined $limits{$type} && (!$limits{$type} || !$limits{'*'})) {
            fatal "unexpected block ($type) in file $f";
        }
        _read_file($include, $report, %limits) if $include;
    }
    return $report;
}

sub _strip_comments {
    s{\A(\s*(?:#.*)?\n)+}{};
}

sub _strip_whitespace {
    s{\A\s+}{};
}

sub _metadata {
    return _keyval_block(qr/meta(?:data)?/, sub {
        local $_ = shift;
        my ($k) = @_;
        my $line = $k . ' ' . $_;
        return _bareword() // _filepath() //_quoted_string_value()
            // fatal "invalid metadata: $line";
    });
}

sub _iostep {
    my $read = _read_block() // return;  # _string_block('read') // return;
    _strip_comments();
    _strip_whitespace();
    my $write = _write_block() // fatal "reader without writer";  # _string_block('write') // fatal "reader without writer";
    return {
        'read' => $read,
        'write' => $write,
    };
}

sub _read_block {
    return if !s{
        \A
        \s*
        read
        \s+
        from
        \s+
    }{}x;
    my $database = _bareword() // fatal("expected database ID: ", (split /\n/, $_, 2)[0]);
    fatal "incomplete read block"
        if !s{\A\s+\{\s*}{};
    my $body = '';
    my %block = ('id' => $database);
    while (!s{\A\s*\}}{}) {
        fatal if !s{(.+\n)}{};
        $body .= $1;
    }
    $block{'body'} = $body;
    return \%block;
}

sub _write_block {
    return if !s{
        \A
        \s*
        write
        (?:
            \s+
            to
            \s+
            (\w+)
        )?
        \s+
        \{
    }{}x;
    my $database = $1 // 'output';
    my $body = '';
    my %block = ('id' => $database);
    while (!s{\A\s*\}}{}) {
        fatal if !s{(.+\n)}{};
        $body .= $1;
    }
    $block{'body'} = $body;
    return \%block;
}

sub _database {
    return _keyval_block(qr/(database|source|destination|output)/, sub {
        local $_ = shift;
        my ($k, $block) = @_;
        $block->{'read_only'} = 1 if $block->{'type'} eq 'source';
        $block->{'id'} = $block->{'title'} if defined $block->{'title'} && $block->{'id'} =~ /^(?:source|destination)$/;
        my $line = $k . ' ' . $_;
        if ($k =~ /^(dsn|user|password)$/) {
            return _quoted_string_value() // fatal "invalid $k: $line";
        }
        elsif ($k eq 'options') {
            my %opt;
            while (/\S/) {
                my $opt = _bareword() // fatal "expected option key: $line";
                s/\A\s+//;
                my $val = _quoted_string_value() // 1;
                $opt{$opt} = $val;
                s/\A\s*,//;  # Optional comma
                s/\A\s+//;
                last if s/\A;\s*//;
            }
            return \%opt;
        }
    });
}

sub _parameters {
    return _keyval_block(qr/param(?:eter)?s/, sub {
        local $_ = shift;
        my ($k) = @_;
        my $line = $k . ' ' . $_;
        my $title = _quoted_string_value()
            or fatal "untitled parameter: $line";
        my %qual;
        while (!s{\A\s*;\z}{}) {
            s{\A\s+}{};
            my $w = _bareword() or fatal "unrecognized token in parameter definition: $line";
            if ($w =~ /^(default|hint|example|match(?:es|ing)?)$/) {
                s{\A\s+}{} or fatal "parameter qualifier $w not followed by whitespace: $line";
                my $v = _quoted_string_value() // _bareword()
                    // fatal "parameter qualifier $w lacks required value: $line";
                $qual{$w} = $v;
            }
            else {
                $qual{$w} = 1;
            }
            s/\A\s*,//;  # Optional comma
        }
        return {
            'key' => $k,
            'title' => $title,
            'qualifiers' => \%qual,
        };
    });
}

sub _init {
    my $block = _string_block('initialize')
        or return;
    $block->{'target'} = delete $block->{'id'}
        or fatal "no target for initializer";
    return $block;
}

sub _finish {
    my $block = _string_block('finish')
        or return;
    $block->{'target'} = delete $block->{'id'}
        or fatal "no target for finisher";
    return $block;
}

sub _include {
    return if !s/\Ainclude\s+//;
    my $f = _filepath()
        or fatal "include without file argument";
    return $f;
}

sub _string_block {
    my ($rxhead) = @_;
    return if !s{
        \A
        ($rxhead)
        (?:
            \s+ (\w+)
        )?
        (?:
            \s+ "([^"\n]+)"
        )?
        \s+
        \{
    }{}x;
    my $body = '';
    my %block = ('type' => $1, 'id' => $2, 'title' => $3);
    while (!s{\A\s*\}}{}) {
        fatal if !s{(.+\n)}{};
        $body .= $1;
    }
    $block{'body'} = $body;
    return \%block;
}

sub _keyval_block {
    my ($rxhead, $linesub) = @_;
    return if !s{
        \A
        ($rxhead)
        (?:
            \s+ (\w+)
        )?
        (?:
            \s+ "([^"\n]+)"
        )?
        \s+
        \{
    }{}x;
    my %hash;
    my %block = ('type' => $1, 'id' => $2, 'title' => $3, 'body' => \%hash);
    while (1) {
        _strip_comments();
        last if s{\A\s*\}}{};
        fatal "unterminated block" if !/\S/;
        s{\A\s*(\w+)\s+(.+)\n}{}
            or fatal "unrecognized line in $block{'type'}: $_";
        $hash{$1} = $linesub->($2, $1, \%block);
    }
    return \%block;
}

sub _bareword {
    return if !s/\A(\w+)//;
    return $1;
}

sub _filepath {
    return $1 if s{\A(\.{0,2}/[^\s;]+)}{};
    return _quoted_string_value();
}

sub _quoted_string_value {
    return if !s/\A"((?:\\.|[^\\"\n])*)"//;
    return unescape($1);
}

sub unescape {
    local $_ = shift;
    s{\\(.)}{$1}g;
    return $_;
}

sub read_databases {
    foreach my $f (@_) {
        open my $fh, '<', $f or fatal "open $f: $!";
        local $/;
        local $_ = <$fh>;
        close $fh;
        my %database;
        _strip_comments();
        while (my $block = _database()) {
            my $hash = delete $block->{'body'};
            %$hash = ( %$block, %$hash );
            my $id = $hash->{'id'} || 'default';
            $database{$id} = $hash;
            _strip_comments();
        }
    }
    return %database;
}

sub fatal {
    print STDERR "rho: @_\n";
    exit 2;
}

